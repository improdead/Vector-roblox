/**
 * Agent Executor
 *
 * Executes Vector agent prompts with auto-approval in a virtual environment.
 * Connects to the real /api/chat endpoint and applies all proposals automatically.
 *
 * Features:
 * - Real API integration with streaming responses
 * - Automatic proposal application
 * - Detailed tool call tracking
 * - Performance metrics
 * - Comprehensive error handling
 *
 * @module testing/runner/agent-executor
 */

import { VirtualEnvironment, Change } from './virtual-env';

/**
 * Result of executing an agent prompt
 */
export interface ExecutionResult {
  prompt: string;              // Original prompt
  toolCalls: ToolCall[];       // All tool calls made
  proposals: Proposal[];       // All proposals generated
  changes: Change[];           // All changes to environment
  finalState: any;             // Final environment state
  duration: number;            // Total execution time (ms)
  success: boolean;            // Whether execution succeeded
  error?: string;              // Error message if failed
  agentResponse?: string;      // Final agent text response
}

/**
 * A single tool call made by the agent
 */
export interface ToolCall {
  timestamp: number;           // When the call was made
  tool: string;                // Tool name (e.g., "create_instance")
  params: any;                 // Tool parameters
  result?: any;                // Tool result (if available)
  duration: number;            // How long the tool took (ms)
}

/**
 * A proposal generated by the agent
 */
export interface Proposal {
  id: string;                  // Proposal ID
  tool: string;                // Tool name
  params: any;                 // Tool parameters
  type: 'edit' | 'instance' | 'asset';  // Proposal type
}

/**
 * Options for agent execution
 */
export interface ExecuteOptions {
  timeout?: number;            // Execution timeout (ms)
  mode?: 'ask' | 'agent';      // Agent mode
  autoApply?: boolean;         // Auto-approve proposals (default: true)
  provider?: any;              // Custom provider config
  model?: string;              // Model override
}

/**
 * Agent Executor Class
 *
 * Executes agent prompts against the real Vector API and applies
 * results to the virtual environment.
 */
export class AgentExecutor {
  private env: VirtualEnvironment;
  private verbose: boolean;
  private baseUrl: string;

  /**
   * Create a new agent executor
   * @param env - Virtual environment to execute in
   * @param verbose - Enable detailed logging
   * @param baseUrl - API base URL (default: http://localhost:3000)
   */
  constructor(
    env: VirtualEnvironment,
    verbose: boolean = false,
    baseUrl: string = 'http://localhost:3000'
  ) {
    this.env = env;
    this.verbose = verbose;
    this.baseUrl = baseUrl;

    this.log('ü§ñ Agent Executor initialized');
  }

  /**
   * Execute an agent prompt
   * @param prompt - The user prompt
   * @param options - Execution options
   * @returns Execution result with all details
   */
  async execute(prompt: string, options: ExecuteOptions = {}): Promise<ExecutionResult> {
    this.log(`\n${'='.repeat(60)}`);
    this.log(`üöÄ Executing prompt: "${prompt}"`);
    this.log('='.repeat(60));

    const startTime = Date.now();
    const toolCalls: ToolCall[] = [];
    const proposals: Proposal[] = [];
    let agentResponse = '';
    let errorMessage: string | undefined;

    try {
      // Get context from virtual environment
      const context = this.env.getContext();
      this.log(`üìã Context gathered (${context.scene.nodes.length} instances)`);

      // Prepare API request
      const requestBody = {
        projectId: 'test-env',
        message: prompt,
        context,
        mode: options.mode || 'agent',
        autoApply: options.autoApply !== false,  // Default to true
        provider: options.provider,
        modelOverride: options.model
      };

      this.log(`üì° Calling API: ${this.baseUrl}/api/chat`);

      // Call real API with streaming
      const controller = new AbortController();
      const timeoutId = options.timeout
        ? setTimeout(() => controller.abort(), options.timeout)
        : null;

      const response = await fetch(`${this.baseUrl}/api/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody),
        signal: controller.signal
      });

      if (timeoutId) clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      }

      this.log('‚úÖ API connected, streaming response...\n');

      // Parse streaming response
      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No response body');
      }

      let buffer = '';
      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (!line.trim()) continue;

          // Handle SSE format (data: {...})
          const dataLine = line.startsWith('data: ') ? line.slice(6) : line;

          if (!dataLine.trim()) continue;

          try {
            const data = JSON.parse(dataLine);

            // Handle different message types
            if (data.type === 'status') {
              this.log(`üìä Status: ${data.message}`);
            }

            else if (data.type === 'tool') {
              this.log(`üîß Tool call: ${data.tool}`);

              const toolCall: ToolCall = {
                timestamp: Date.now(),
                tool: data.tool,
                params: data.params || {},
                duration: 0
              };

              toolCalls.push(toolCall);

              // Log tool details
              if (this.verbose) {
                this.log(`   Params: ${JSON.stringify(data.params).slice(0, 100)}...`);
              }
            }

            else if (data.type === 'proposal') {
              this.log(`üí° Proposal: ${data.proposal?.tool || 'unknown'}`);

              const proposal: Proposal = {
                id: data.proposal?.id || `prop_${proposals.length}`,
                tool: data.proposal?.tool || '',
                params: data.proposal?.params || {},
                type: this.getProposalType(data.proposal?.tool)
              };

              proposals.push(proposal);

              // Auto-apply proposal if enabled
              if (options.autoApply !== false) {
                this.log(`‚ú® Auto-applying proposal...`);
                await this.applyProposal(proposal);
                this.log(`‚úÖ Proposal applied successfully`);
              }
            }

            else if (data.type === 'text' || data.type === 'message') {
              const text = data.text || data.message || '';
              if (text) {
                agentResponse += text;
                if (this.verbose) {
                  process.stdout.write(text);
                }
              }
            }

            else if (data.type === 'done') {
              this.log('\n‚úÖ Agent completed');
            }

            else if (data.type === 'error') {
              throw new Error(data.error || 'Unknown error from agent');
            }

          } catch (parseError) {
            // Skip non-JSON lines
            if (this.verbose && !line.startsWith(':')) {
              this.log(`‚ö†Ô∏è  Failed to parse line: ${line.slice(0, 50)}...`);
            }
          }
        }
      }

      const duration = Date.now() - startTime;
      this.log(`\n‚è±Ô∏è  Execution completed in ${duration}ms`);

      // Get final state and changes
      const changes = this.env.getChanges();
      const finalState = this.env.exportState();

      return {
        prompt,
        toolCalls,
        proposals,
        changes,
        finalState,
        duration,
        success: true,
        agentResponse: agentResponse.trim()
      };

    } catch (error) {
      const duration = Date.now() - startTime;
      errorMessage = error instanceof Error ? error.message : String(error);

      this.log(`\n‚ùå Execution failed: ${errorMessage}`);

      return {
        prompt,
        toolCalls,
        proposals,
        changes: this.env.getChanges(),
        finalState: this.env.exportState(),
        duration,
        success: false,
        error: errorMessage,
        agentResponse: agentResponse.trim()
      };
    }
  }

  /**
   * Apply a proposal to the virtual environment
   * @param proposal - Proposal to apply
   */
  private async applyProposal(proposal: Proposal): Promise<void> {
    const { tool, params } = proposal;

    try {
      switch (tool) {
        case 'apply_edit':
          this.applyEdit(params);
          break;

        case 'create_instance':
          this.createInstance(params);
          break;

        case 'set_properties':
          this.setProperties(params);
          break;

        case 'rename_instance':
          this.renameInstance(params);
          break;

        case 'delete_instance':
          this.deleteInstance(params);
          break;

        case 'insert_asset':
          // Not implemented in virtual env (requires actual Roblox API)
          this.log(`‚ö†Ô∏è  insert_asset not supported in virtual env`);
          break;

        default:
          this.log(`‚ö†Ô∏è  Unknown tool: ${tool}`);
      }
    } catch (error) {
      this.log(`‚ùå Failed to apply proposal: ${error}`);
      throw error;
    }
  }

  /**
   * Apply a code edit to a file
   * @param params - Edit parameters
   */
  private applyEdit(params: any): void {
    const { path, edits, newContent } = params;

    if (newContent !== undefined) {
      // Simple case: full content replacement
      this.env.updateFile(path, newContent);
    } else if (edits && Array.isArray(edits)) {
      // Apply individual edits
      const file = this.env.getFile(path);
      if (!file) {
        throw new Error(`File not found: ${path}`);
      }

      let content = file.content;

      // Sort edits in reverse order
      const sorted = [...edits].sort((a: any, b: any) => {
        if (a.start.line !== b.start.line) return b.start.line - a.start.line;
        return b.start.character - a.start.character;
      });

      // Apply edits
      for (const edit of sorted) {
        content = this.applyTextEdit(content, edit);
      }

      this.env.updateFile(path, content);
    }
  }

  /**
   * Apply a single text edit
   * @param content - Original content
   * @param edit - Edit to apply
   * @returns Modified content
   */
  private applyTextEdit(content: string, edit: any): string {
    const lines = content.split('\n');
    const { start, end, text } = edit;

    const before = lines[start.line].slice(0, start.character);
    const after = lines[end.line].slice(end.character);
    const newLine = before + text + after;

    lines[start.line] = newLine;

    // Remove lines in between if multi-line edit
    if (end.line > start.line) {
      lines.splice(start.line + 1, end.line - start.line);
    }

    return lines.join('\n');
  }

  /**
   * Create an instance
   * @param params - Instance parameters
   */
  private createInstance(params: any): void {
    const { parent, className, name, properties } = params;
    this.env.createInstance(parent, className, name, properties || {});
  }

  /**
   * Set instance properties
   * @param params - Property parameters
   */
  private setProperties(params: any): void {
    const { path, properties } = params;
    this.env.setProperties(path, properties);
  }

  /**
   * Rename an instance
   * @param params - Rename parameters
   */
  private renameInstance(params: any): void {
    const { path, newName } = params;
    this.env.renameInstance(path, newName);
  }

  /**
   * Delete an instance
   * @param params - Delete parameters
   */
  private deleteInstance(params: any): void {
    const { path } = params;
    this.env.deleteInstance(path);
  }

  /**
   * Determine proposal type from tool name
   * @param tool - Tool name
   * @returns Proposal type
   */
  private getProposalType(tool: string): 'edit' | 'instance' | 'asset' {
    if (tool === 'apply_edit' || tool === 'show_diff') return 'edit';
    if (tool === 'insert_asset' || tool === 'search_assets') return 'asset';
    return 'instance';
  }

  /**
   * Log a message if verbose mode is enabled
   * @param message - Message to log
   */
  private log(message: string): void {
    if (this.verbose) {
      console.log(`[AgentExec] ${message}`);
    }
  }
}
